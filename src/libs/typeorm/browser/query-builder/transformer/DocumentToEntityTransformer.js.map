{"version":3,"sources":["../browser/src/query-builder/transformer/DocumentToEntityTransformer.ts"],"names":[],"mappings":"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","file":"DocumentToEntityTransformer.js","sourcesContent":["import { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EmbeddedMetadata } from \"../../metadata/EmbeddedMetadata\"\nimport { EntityTarget } from \"../../common/EntityTarget\"\n\n/**\n * Transforms raw document into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class DocumentToEntityTransformer {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    entity: EntityTarget<ObjectLiteral>\n\n    constructor(\n        // private selectionMap: AliasMap,\n        // private joinMappings: JoinMapping[],\n        // private relationCountMetas: RelationCountAttribute[],\n        // private enableRelationIdValues: boolean = false,\n        entityClassOrName: EntityTarget<ObjectLiteral>,\n    ) {\n        // console.dir(entityClassOrName)\n        this.entity = entityClassOrName\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transformAll(documents: ObjectLiteral[], metadata: EntityMetadata) {\n        return documents.map((document) => this.transform(document, metadata))\n    }\n\n    transform(document: any, metadata: EntityMetadata) {\n        const entity: any = metadata.create(undefined, {\n            fromDeserializer: true,\n        })\n        // const Entity = this.entity;\n        // const entity = new Entity({a:1})\n        let hasData = false\n\n        // handle _id property the special way\n        // if (metadata.objectIdColumn?.propertyName)\n        //     console.dir(metadata.objectIdColumn?.propertyName)\n\n        if (\n            metadata.objectIdColumn &&\n            document[metadata.objectIdColumn.databaseNameWithoutPrefixes]\n        ) {\n            // todo: we can't use driver in this class\n            // do we really need prepare hydrated value here? If no then no problem. If yes then think maybe prepareHydratedValue process should be extracted out of driver class?\n            // entity[metadata.objectIdColumn.propertyName] = this.driver.prepareHydratedValue(document[metadata.objectIdColumn.name\"], metadata.objectIdColumn);\n\n            entity[metadata.objectIdColumn.propertyName] =\n                document[metadata.objectIdColumn.databaseNameWithoutPrefixes]\n            hasData = true\n        }\n\n        // console.dir(metadata.ownColumns, { depth: null })\n\n        // add special columns that contains relation ids\n        // if (this.enableRelationIdValues) {\n        //     metadata.columns\n        //         .filter((column) => !!column.relationMetadata)\n        //         .forEach((column) => {\n        //             const valueInObject =\n        //                 document[column.databaseNameWithoutPrefixes]\n        //             if (\n        //                 valueInObject !== undefined &&\n        //                 valueInObject !== null &&\n        //                 column.propertyName\n        //             ) {\n        //                 // todo: we can't use driver in this class\n        //                 // const value = this.driver.prepareHydratedValue(valueInObject, column);\n        //                 entity[column.propertyName] = valueInObject\n        //                 hasData = true\n        //             }\n        //         })\n        // }\n\n        // console.log(\"metadata.embeddeds >>>\")\n        // console.dir(metadata.embeddeds, { depth: null })\n\n        /*this.joinMappings\n            .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.relationOwnerSelection && joinMapping.alias.target)\n            .map(joinMapping => {\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, joinMapping.alias);\n                const isResultArray = joinMapping.isMany;\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\n\n                if (result && (!isResultArray || result.length > 0)) {\n                    entity[joinMapping.propertyName] = result;\n                    hasData = true;\n                }\n            });*/\n\n        // get value from columns selections and put them into object\n        metadata.ownColumns.forEach((column) => {\n            // const valueInObject = document[column.databaseNameWithoutPrefixes]\n            const valueInObject = document[column.propertyName]\n            if (\n                valueInObject !== undefined &&\n                column.propertyName &&\n                !column.isVirtual\n            ) {\n                // const value = this.driver.prepareHydratedValue(valueInObject, column);\n\n                entity[column.propertyName] = valueInObject\n\n                // if(column.databaseName != column.propertyName)\n\n                hasData = true\n            }\n        })\n\n        const addEmbeddedValuesRecursively = (\n            entity: any,\n            document: any,\n            embeddeds: EmbeddedMetadata[],\n        ) => {\n            embeddeds.forEach((embedded) => {\n                if (!document[embedded.prefix]) return\n\n                if (embedded.isArray) {\n                    entity[embedded.propertyName] = (\n                        document[embedded.prefix] as any[]\n                    ).map((subValue: any, index: number) => {\n                        const newItem = embedded.create({\n                            fromDeserializer: true,\n                        })\n                        embedded.columns.forEach((column) => {\n                            newItem[column.propertyName] =\n                                subValue[column.databaseNameWithoutPrefixes]\n                        })\n                        addEmbeddedValuesRecursively(\n                            newItem,\n                            document[embedded.prefix][index],\n                            embedded.embeddeds,\n                        )\n                        return newItem\n                    })\n                } else {\n                    if (\n                        embedded.embeddeds.length &&\n                        !entity[embedded.propertyName]\n                    )\n                        entity[embedded.propertyName] = embedded.create({\n                            fromDeserializer: true,\n                        })\n\n                    embedded.columns.forEach((column) => {\n                        const value =\n                            document[embedded.prefix][\n                                column.databaseNameWithoutPrefixes\n                            ]\n                        if (value === undefined) return\n\n                        if (!entity[embedded.propertyName])\n                            entity[embedded.propertyName] = embedded.create({\n                                fromDeserializer: true,\n                            })\n\n                        entity[embedded.propertyName][column.propertyName] =\n                            value\n                    })\n\n                    addEmbeddedValuesRecursively(\n                        entity[embedded.propertyName],\n                        document[embedded.prefix],\n                        embedded.embeddeds,\n                    )\n                }\n            })\n        }\n\n        addEmbeddedValuesRecursively(entity, document, metadata.embeddeds)\n\n        // if relation is loaded then go into it recursively and transform its values too\n        // console.dir(metadata.relations, { depth: null })\n        /*metadata.relations.forEach(relation => {\n            const relationAlias = this.selectionMap.findSelectionByParent(alias.name, relation.propertyName);\n            if (relationAlias) {\n                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"join\" && joinMapping.alias === relationAlias);\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, relationAlias);\n                const isResultArray = relation.isManyToMany || relation.isOneToMany;\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\n\n                if (result) {\n                    let propertyName = relation.propertyName;\n                    if (joinMapping) {\n                        propertyName = joinMapping.propertyName;\n                    }\n\n                    if (relation.isLazy) {\n                        entity[\"__\" + propertyName + \"__\"] = result;\n                    } else {\n                        entity[propertyName] = result;\n                    }\n\n                    if (!isResultArray || result.length > 0)\n                        hasData = true;\n                }\n            }\n\n            // if relation has id field then relation id/ids to that field.\n            if (relation.isManyToMany) {\n                if (relationAlias) {\n                    const ids: any[] = [];\n                    const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"relationId\" && joinMapping.alias === relationAlias);\n\n                    if (relation.idField || joinMapping) {\n                        const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;\n                        const junctionMetadata = relation.junctionEntityMetadata;\n                        const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;\n\n                        rawSqlResults.forEach(results => {\n                            if (relationAlias) {\n                                const resultsKey = relationAlias.name + \"_\" + columnName;\n                                const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);\n                                if (value !== undefined && value !== null)\n                                    ids.push(value);\n                            }\n                        });\n\n                        if (ids && ids.length)\n                            entity[propertyName] = ids;\n                    }\n                }\n            } else if (relation.idField) {\n                const relationName = relation.name;\n                entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + \"_\" + relationName], relation.referencedColumn);\n            }\n\n            // if relation counter\n            this.relationCountMetas.forEach(joinMeta => {\n                if (joinMeta.alias === relationAlias) {\n                    // console.log(\"relation count was found for relation: \", relation);\n                    // joinMeta.entity = entity;\n                    joinMeta.entities.push({ entity: entity, metadata: metadata });\n                    // console.log(joinMeta);\n                    // console.log(\"---------------------\");\n                }\n            });\n        });*/\n\n        return hasData ? entity : null\n    }\n}\n"],"sourceRoot":"../.."}